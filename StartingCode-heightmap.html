<html>
<head>
	<title>Starting Code for 1st Project 2017</title>
	<style>

	body {
		font-family: Monospace;
		background-color: #f0f0f0;
		margin: 0px;
		overflow: hidden;
	}

	canvas {
		width: 100%;
		height: 100%;
	}

	</style>
	<script src="lib/three.min.js"></script>
	<script src="lib/stats.min.js"></script>
	<script src="lib/Coordinates.js"></script>
	<script src="lib/OrbitControls.js"></script>
	<script src="classes/heightmap.js"></script>
	<script src="classes/maze.js"></script>
	<script src="classes/minotaur.js"></script>
	<script src="classes/character.js"></script>
	<script src="classes/solution.js"></script>

</head>
<body>

	<script>

	var scene, camera, renderer, controls, stats;
	var character, minotaur;
	var matrixSolution;
	var dimX, dimZ;
	var posizionato = false;//controlla se il personaggio è stato posizionato nel labirinto
	var animazione = true;
	var posizione = new THREE.Vector3();
	var startA = Date.now()/1000;
	var prec = 0;
	var mps = 8; //movimenti al secondo del personaggio


	function Start() {
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

		renderer = new THREE.WebGLRenderer( {antialias: true} );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setClearColor( 0xf0f0f0 );
		document.body.appendChild( renderer.domElement );

		camera.position.set(0,30,30);
		camera.lookAt( new THREE.Vector3(0,0,0));

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		document.body.appendChild( stats.domElement );

		hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
		hemiLight.color.setHSL( 0.6, 1, 0.6 );
		hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
		hemiLight.position.set( 0, 500, 0 );
		hemiLight.castShadow = true;
		scene.add( hemiLight );

		dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
		dirLight.color.setHSL( 0.1, 1, 0.95 );
		dirLight.position.set( -1, 1.75, 1 );
		dirLight.position.multiplyScalar( 50 );
		scene.add( dirLight );
		dirLight.castShadow = true;
		dirLight.shadow.mapSize.width = 1024;
		dirLight.shadow.mapSize.height = 1024;

		addGround();
		// uncomment if you need to draw coordinate axes when building the scene
		//Coordinates.drawAllAxes();

		controls = new THREE.OrbitControls( camera );
		controls.addEventListener( 'change', Render );

		//labirinto e minotauro
		var m = new Maze("textures/circular/cLab_90.png",10); //percorso della texture e altezza
		var min = new Minotaur();
		var char = new Character();

		var maze = m.getMaze();
		minotaur = min.getMinotaur();
		character = char.getCharacter();

		scene.add(maze);

		maze.add(minotaur);


		minotaur.position.set(-8,0,0);
		minotaur.rotation.y = Math.PI/2;

		var image = new Image();

		image.src = 'textures/circular/cLab_sol_90.png';

		image.onload = function (){
			loadMatrixSolution(image);
			dimX = matrixSolution[0].length;
			dimZ = matrixSolution.length;
			console.log(dimX+","+dimZ);
			//aggiungo il personaggio
			scene.add(character);
			posizionato = true;
			posizione.set(0,0,0); //inizializza la posizione del personaggio al centro del labitinto
		}

	}

	function loadMatrixSolution(image){
		var sol = new Solution(image);
		sol.createSolution();
		sol.drawSolution();
		matrixSolution = sol.getSolution();
	}

	function Update() {
		requestAnimationFrame( Update );
		controls.update();
		stats.update();

		var t = (Date.now()/1000)-startA;

		if(t-prec>(1/mps) && posizionato && animazione){ //verifico che tra il tempo precedente e quello attuale sia passato almeno un secondo
			calcolaPosizione();
			character.position.copy(posizione);
			prec = t;
		}

		Render();
	}

	function Render() {
		renderer.render(scene, camera);
	}

	function calcolaPosizione(){
		var x = posizione.x;
		var z = posizione.z;
		var xS = x+(dimX/2);
		var zS = z+(dimZ/2);
		var trovato = false;

		console.log(xS+","+zS);

		for(var i = -1; i <= 1; i++){
			for(var j = -1; j <= 1; j++){
				if(i==0 && j==0) continue;

				if((xS+i>=0 && xS+i<dimX) && (zS+j>=0 && zS<dimZ)){
					if(matrixSolution[xS+i][zS+j]==1){
						posizione.set(x+i,0,z+j);
						matrixSolution[xS+i][zS+j]=0;//modifico il valore nella matrice per "dire" che la posizione è gia stata visitata
						trovato = true;
						break; //ho trovato la posizione successiva e posso uscire interrompere
					}
				}
				else{//arrivato alla fine del labirinto
					animazione = false;
					break;
				}
			}
			if(!animazione || trovato) break;
		}

	}


	function addGround(){
		var groundGeo = new THREE.PlaneBufferGeometry(1000,1000 );
		var textureGround = new THREE.TextureLoader().load('textures/sand.jpg');
		textureGround.wrapS = THREE.RepeatWrapping;
		textureGround.wrapT = THREE.RepeatWrapping;
		textureGround.repeat.set(100,100);
		var groundMat = new THREE.MeshPhongMaterial({map: textureGround});
		var ground = new THREE.Mesh( groundGeo, groundMat );
		ground.rotation.x = -Math.PI/2;
		scene.add( ground );
		ground.receiveShadow = true;

	}


	Start();
	Update();

	</script>
</body>
</html>
